#!/bin/sh

# dotdeploy - configurable dotfile and directory management
#
# Running this script looks for all *.deploy files in PWD,
# and sources them. Consequently, those need sh compliant
# syntax and definitions distinct from the script's.
#
# Example Usage:
#   ./dotdeploy conffiles   # where example.deploy is in .
#
# Example conf:
#   # in file: example.deploy
#   conffiles=('conf_home') # defines a compound target
#                           #  of sequential subtargets
#   conf_home=(       # begin target definition
#     . ~             # defines relative base source and base target for actions
#     d bin           # mkdir ~/bin
#     f .bash_history # touch ~/.bash_history
#     @ . .bashrc     # ln -s ././.bashrc ~/.bashrc
#   )                 # end target definition


### setup output

if [ "$1" = "-v" ] ; then
    alias vecho='echo '
    shift
else
    alias vecho='true '
fi

alias errcho='>&2 echo \! '


### load user conf

vecho "looking for .deploy files..."

for conf in $PWD/*.deploy; do
    vecho "  found: $(basename $conf)"
    source $conf
done


### DSL actions

# $1 -> target base dir
# $2 -> directory to create
action_mkdir () {
    local target="$1/$2"
    vecho "    mkdir: $target"
    mkdir -p "$target"
}

# $1 -> target base dir
# $2 -> file to create
action_mkfile () {
    local target="$1/$2"
    vecho "    touch: $target"
    touch "$target"
}

# $1 -> source base dir
# $2 -> target base dir
# $3 -> source directory for file, rel. to $1
# $4 -> target file, rel. to $2
action_mirror () {
    local source="$1/$3/$(basename $4)"
    local target="$2/$4"
    vecho "    mirror: $target -> $source"
    # check if file already exists
    if [ -e "$target" ]; then
        local already_file=$(file -b "$target")
        errcho "      IGNORING!  target already is a file:"
        errcho "        path:     $target"
        errcho "        filetype: $already_file"
    # no file exists, copying is safe
    else
        cp "$source" "$target"
    fi
}

# $1 -> source base dir
# $2 -> target base dir
# $3 -> source directory for file, rel. to $1
# $4 -> target file, rel. to $2
action_hardlink () {
    local source="$1/$3/$(basename $4)"
    local target="$2/$4"
    vecho "    hardln: $target -> $source"
    # check if file already exists
    if [ -e "$target" ]; then
        local already_file=$(file -b "$target")
        errcho "      IGNORING!  target already is a file:"
        errcho "        path:     $target"
        errcho "        filetype: $already_file"
    # no file exists, copying is safe
    else
        cp -l "$source" "$target"
    fi
}

# $1 -> source base dir
# $2 -> target base dir
# $3 -> source directory for file, rel. to $1
# $4 -> target file, rel. to $2
action_symlink () {
    local source="$1/$3/$(basename $4)"
    local target="$2/$4"
    vecho "    symln: $target -> $source"
    # check if link already exists
    if [ -L "$target" ]; then
        local already_link=$(readlink -f "$target")
        errcho "      REPLACING! target already is a link:"
        errcho "        path:     $target"
        errcho "        readlink: $already_link"
        ln -sfT "$source" "$target"
    # check if any other sort of file exists
    elif [ -e "$target" ]; then
        local already_file=$(file -b "$target")
        errcho "      IGNORING!  target already is a non-link file:"
        errcho "        path:     $target"
        errcho "        filetype: $already_file"
    # no file exists, symlinking is safe
    else
        ln -s "$source" "$target"
    fi
}


### DSL parsing & dispatch

# $1 -> source base dir
# $2 -> target base dir
# $3 -> array of commands, arguments and $3
handle_actions () {
    vecho '    processing directives...'
    source_base_dir=$(cd "$1"; pwd)
    [ -d "$2" ] || echo "      mkdir $2" && mkdir -p "$2"
    target_base_dir=$(cd "$2"; pwd)
    shift 2
    while [ ! $# -eq 0 ] ; do
    case "$1" in
        d)
            action_mkdir "$target_base_dir" "$2"
            shift
            ;;
        f)
            action_mkfile "$target_base_dir" "$2"
            shift
            ;;
        l)
            action_hardlink "$source_base_dir" "$target_base_dir" "$2" "$3"
            shift 2
            ;;
        m)
            action_mirror "$source_base_dir" "$target_base_dir" "$2" "$3"
            shift 2
            ;;
        @)
            action_symlink "$source_base_dir" "$target_base_dir" "$2" "$3"
            shift 2
            ;;
        *)
            errcho "illegal directive: $2"
            ;;
    esac
    shift
    done
}

# read a target
# $1 - target name
handle_target () {
    if [ "${!1}" = '@' ] ; then
        vecho "  compound: $1 (destructuring...)"
        target_array="\${${1}[@]:1}"
        for target in $(eval echo "$target_array"); do
            handle_target "$target"
        done
    else
        vecho "  target: $1";
        arg_array="${1}[@]"
        handle_actions "${!arg_array}"
    fi
}

# $@ - targets to handle
handle_targets () {
    vecho 'handling targets...'
    for target in "$@"; do
         handle_target "$target"
    done
}


handle_targets "$@"

exit 0
